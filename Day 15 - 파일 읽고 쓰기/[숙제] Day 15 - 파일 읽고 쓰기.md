### 1. 파일 읽기

- matrix를 읽는 함수를 구현해봅시다.
    - **input**
        - filename: input 파일의 경로
    - **output**
        - matrix를 표현하는 list
- input 파일의 matrix 포맷
    - 각 row는 newline으로 구분되어 있다.
    - 각 column은 space로 구분되어 있다.
    - 예) './sample-mat.txt'
        ```
        -1 2 1
        5 2 -1
        3 2 1
        ```
- output 파일
    - 행렬은 row vector들의 list로 표현하면 된다.
    - 예) `[[-1, 2, 1], [5, 2, -1], [3, 2, 1]]`



### 2. Bubble sort

- 숫자들을 오름차순으로 정렬하는 (즉, sorting 하는) 알고리즘 중 하나인 Bubble sort를 구현해 보자.
- **input**: unsorted list
- **output**: sorted list
- Bubble sort 설명
    - 주어진 lst의 맨 끝에 maximum 값을 채워 넣는 식으로 구현할 수 있다.
    - 이 때 크기 2짜리인 sliding window 가 움직이는 것으로 생각하고, window 안에서 원하는 조건일 때 원소를 swap (두 개의 원소를 자리바꿈) 한다.
        - window는 아래 예시에서 [..., ```원소1, 원소2```, ...] 처럼 표시한다.
    - 예시) 
        + [5, 1, 2, 6, 2, 1] 가 주어졌다. 
        + stage 0: [5, 1, 2, 6, 2, 1] 에서 최대값은 6이다. 목표는 6을 맨 뒤로 밀어 넣는 것.
            * [```5, 1```, 2, 6, 2, 1]: {5, 1} 에서 5가 크니까 뒤로 보낸다. 즉, 5와 1의 순서를 바꾼다.
            * [```1, 5```, 2, 6, 2, 1]: 이 되었다.
            * [1, ```5, 2```, 6, 2, 1]: {5, 2} 에서 5가 크니까 뒤로 보낸다. 즉, 5와 2의 순서를 바꾼다.
            * [1, ```2, 5```, 6, 2, 1]: 이 되었다.
            * [1, 2, ```5, 6```, 2, 1]: {5, 6} 에서 6이 크니까 그대로 둔다.
            * [1, 2, 5, ```6, 2```, 1]: {6, 2} 에서 6이 크니까 뒤로 보낸다. 즉, 6과 2의 순서를 바꾼다.
            * [1, 2, 5, ```2, 6```, 1]: 이 되었다.
            * [1, 2, 5, 2, ```6, 1```]: {6, 1} 에서 6이 크니까 뒤로 보낸다. 즉, 6과 1의 순서를 바꾼다.
            * [1, 2, 5, 2, ```1, 6```]: 이 되었다. 끝에 도달했으니 stage 0은 끝이 난다.
        + stage 1: [1, 2, 5, 2, 1, **6**] 에서 마지막 6을 제외하고 최대값은 5이다. 목표는 5를 6 바로 앞까지 뒤로 밀어 넣는 것.
            * [```1, 2```, 5, 2, 1, **6**]: {1, 2} 에서 순서가 잘 맞으니 그대로 둔다.
            * [1, ```2, 5```, 2, 1, **6**]: {2, 5} 에서 순서가 잘 맞으니 그대로 둔다.
            * [1, 2, ```5, 2```, 1, **6**]: {5, 2} 에서 순서가 뒤바뀌었으니 순서를 바꾼다.
            * [1, 2, ```2, 5```, 1, **6**]: 가 되었다.
            * [1, 2, 2, ```5, 1```, **6**]: {5, 1} 에서 순서가 뒤바뀌었으니 순서를 바꾼다.
            * [1, 2, 2, ```1, 5```, **6**]: 가 되었다. 끝에 도달했으니 stage 1은 끝이 난다.
        + stage 2: [1, 2, 2, 1, **5, 6**] 에서 목표는 2를 뒤로 밀어 넣는 것. 아래에는 자세한 설명을 생략하고 lst의 변화 양상만을 포함. 
            * [```1, 2```, 2, 1, **5, 6**]
            * [1, ```2, 2```, 1, **5, 6**]
            * [1, 2, ```2, 1```, **5, 6**]: Swap 필요
            * [1, 2, ```1, 2```, **5, 6**]: 가 되었다. 끝에 도달했으니 stage 2는 끝이 난다.
        + stage 3: [1, 2, 1, **2, 5, 6**] 에서 목표는 2를 뒤로 밀어 넣는 것.
            * [```1, 2```, 1, **2, 5, 6**]
            * [1, ```2, 1```, **2, 5, 6**]: Swap 필요
            * [1, ```1, 2```, **2, 5, 6**]: 가 되었다. 끝에 도달했으니 stage 3은 끝이 난다.
        + stage 4: [1, 1, **2, 2, 5, 6**]: 에서 목표는 1을 가장 뒤에 두는 것.
            * [```1, 1```, **2, 2, 5, 6**]: Swap 필요 없고, 끝에 도달했으니 stage 4는 끝이 난다.
        + 끝!
- 아래 skeleton code를 사용해도 됩니다.
    ```python
    def bubble_sort(lst):
        for stage in range(0, len(lst)):
            # lst[0: len(lst) - stage] 의 범위 내의 최대값을, 
            # lst[len(lst) - stage - 1] 에 넣는 것이 목표.
            
            for j in range(0, ???):
                # j는 현재 window의 왼쪽 위치(index)를 의미한다.
    
                if lst[j] ? lst[j + 1]:
                    # Swap lst[j] and lst[j + 1]
                    ????
    ```